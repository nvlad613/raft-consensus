# Raft Consensus
**Авторы**: Владислав Ненов P34082, Михаил Передрий P32102

## 1. Требования к разработанному ПО
### Функциональные требования:  
Реализация алгоритма Raft для достижения консенсуса в распределенной системе.
  
1. Составляющие алгоритма:  
   - Выборов лидера  
   - Репликации логов
   - Обработка крайних случаев (временная недоступность узлов системы, перебои в работе и тд)    
2. Внешний API:  
   - Добавления узлов в кластер.  
   - Отправки данных лидеру.  
   - Создания снэпшотов лога.  

### Нефункциональные требования:  
- Отказоустойчивость при потере сообщений.  
- Гарантия согласованности данных.  
- Минимальная задержка при выборах лидера (таймауты ~150-300 мс).  

### Описание алгоритма:  
Полное описание алгоритма, согласно которому проводилась имплементация можно найти по [ссылкe](https://raft.github.io/raft.pdf).

Алгоритм Raft разделен на три ключевых этапа:  
1. **Выборы лидера**:  
   - Узлы переходят в состояние *кандидата* при истечении таймера
   - Узлы-кандидаты начинают голосование за "лидерство" в кластере
   - Один из кандидатов собирает голоса большинства и становится лидером  
2. **Репликация логов**:  
   - Лидер рассылает записи последовательно всем узлам. 
   - После репликации на большинстве узлов, запись считается подтвержденной 
   - В случае обнаружения неконсистентности данных в процессе обработки ответа на *heartbeat* запрос, лидер добивается согласованности данных во всем кластере  

При этом каждый узел системы может находиться только в одном из 3-х состояний: `последователь(follower)`, `кандидат(candidate)` и `лидер(leader)`. 

---

## 2. Реализация  
### Основные модули:  
- **raft.erl**: непосредственно самого алгоритма по шаблону `gen_fsm`.  
- **log.erl**: Управление логами (добавление, коммит, снэпшоты).  
- **snapshot_providers/***: провайдеры, ответственные за создание снэпшотов лога.
- **tests/***: Несколько тестов на простейшие сценарии.  

---

## 3. Ввод/вывод программы  

1. **Добавление узла**:  
   ```erlang
   gen_statem:cast(RaftPid, {add_node, NodePid}).
   ```  
2. **Отправка данных**:  
   ```erlang
   gen_statem:cast(LeaderPid, {client_add_data, "Hello"}).
   ```  
3. **Создание снэпшота**:  
   ```erlang
   gen_statem:call(RaftPid, log_snapshot).
   ```  

Помимо этого подробнее изучить переходы между состояними и логику работы программы можно заглянув в `logs/debug.log`.


## 4. Выводы  
В процессе работы мы изучили спецификацию алгоритма консенсуса *Raft* и имплементировали его с использованием шаблона `gen_fsm` на языке программирования Erlang.
